// r2papi main file
Object.defineProperty(G, "__esModule", { value: true });
G.Base64 = G.NativePointer = G.R2Papi = G.Assembler = void 0;
var shell_js_1 = G;//"./shell.js");
;
;
;
;
;
;
;
;
var Assembler = /** @class */ (function () {
    function Assembler(myr2) {
        this.program = "";
        this.labels = {};
        this.endian = false;
        this.pc = 0;
        this.r2 = null;
        this.r2 = (typeof myr2 === 'undefined') ? G.r2 : myr2;
        this.program = '';
        this.labels = {};
    }
    Assembler.prototype.setProgramCounter = function (pc) {
        this.pc = pc;
    };
    Assembler.prototype.setEndian = function (big) {
        this.endian = big;
    };
    Assembler.prototype.toString = function () {
        return this.program;
    };
    Assembler.prototype.append = function (x) {
        this.pc += x.length / 2;
        this.program += x;
    };
    // api
    Assembler.prototype.label = function (s) {
        var pos = this.pc; // this.#program.length / 4;
        this.labels[s] = this.pc;
        return pos;
    };
    Assembler.prototype.asm = function (s) {
        var hex = this.r2.cmd('""pa ' + s).trim();
        if (hex.length < 16) {
            // ok
        }
        else {
            hex = "____";
            // console.error("Invalid instruction: " + s);
        }
        this.append(hex);
    };
    return Assembler;
}());
G.Assembler = Assembler;
var R2Papi = /** @class */ (function () {
    function R2Papi(r2) {
        this.r2 = r2;
    }
    R2Papi.prototype.getBaseAddress = function () {
        return new NativePointer(this.cmd("e bin.baddr"));
    };
    R2Papi.prototype.jsonToTypescript = function (name, a) {
        var str = "interface ".concat(name, " {\n");
        if (a.length && a.length > 0) {
            a = a[0];
        }
        for (var _i = 0, _a = Object.keys(a); _i < _a.length; _i++) {
            var k = _a[_i];
            var typ = typeof (a[k]);
            var nam = k;
            str += "    ".concat(nam, ": ").concat(typ, ";\n");
        }
        return "".concat(str, "}\n");
    };
    R2Papi.prototype.setLogLevel = function (level) {
        this.cmd('e log.level=' + level);
        return this;
    };
    /**
     * should return the id for the new map using the given file descriptor
     */
    R2Papi.prototype.newMap = function (fd, vaddr, size, paddr, perm, name) {
        if (name === void 0) { name = ""; }
        this.cmd("om ".concat(fd, " ").concat(vaddr, " ").concat(size, " ").concat(paddr, " ").concat(perm, " ").concat(name));
    };
    R2Papi.prototype.at = function (a) {
        return new NativePointer(a);
    };
    R2Papi.prototype.getShell = function () {
        return new shell_js_1.R2PapiShell(this);
    };
    // Radare/Frida
    R2Papi.prototype.version = function () {
        return this.r2.cmd("?Vq").trim();
    };
    // Process
    R2Papi.prototype.platform = function () {
        return this.r2.cmd("uname").trim();
    };
    R2Papi.prototype.arch = function () {
        return this.r2.cmd("uname -a").trim();
    };
    R2Papi.prototype.bits = function () {
        return this.r2.cmd("uname -b").trim();
    };
    R2Papi.prototype.id = function () {
        // getpid();
        return +this.r2.cmd("?vi:$p");
    };
    // Other stuff
    R2Papi.prototype.printAt = function (msg, x, y) {
        // see pg, but pg is obrken :D
    };
    R2Papi.prototype.clearScreen = function () {
        this.r2.cmd("!clear");
        return this;
    };
    R2Papi.prototype.getConfig = function (key) {
        return this.r2.call("e " + key).trim();
    };
    R2Papi.prototype.setConfig = function (key, val) {
        this.r2.call("e " + key + "=" + val);
        return this;
    };
    R2Papi.prototype.getRegisters = function () {
        // this.r2.log("winrar" + JSON.stringify(JSON.parse(this.r2.cmd("drj")),null, 2) );
        return this.cmdj("drj");
    };
    R2Papi.prototype.resizeFile = function (newSize) {
        this.cmd("r ".concat(newSize));
        return this;
    };
    R2Papi.prototype.insertNullBytes = function (newSize, at) {
        if (at === undefined) {
            at = "$$";
        }
        this.cmd("r+".concat(newSize, "@").concat(at));
        return this;
    };
    R2Papi.prototype.removeBytes = function (newSize, at) {
        if (at === undefined) {
            at = "$$";
        }
        this.cmd("r-".concat(newSize, "@").concat(at));
        return this;
    };
    R2Papi.prototype.seek = function (addr) {
        this.cmd("s ".concat(addr));
        return this;
    };
    R2Papi.prototype.currentSeek = function () {
        return new NativePointer('$$');
    };
    R2Papi.prototype.seekToRelativeOpcode = function (nth) {
        this.cmd("so ".concat(nth));
        return this.currentSeek();
    };
    R2Papi.prototype.getBlockSize = function () {
        return +this.cmd("b");
    };
    R2Papi.prototype.setBlockSize = function (a) {
        this.cmd("b ".concat(a));
        return this;
    };
    R2Papi.prototype.countFlags = function () {
        return Number(this.cmd("f~?"));
    };
    R2Papi.prototype.countFunctions = function () {
        return Number(this.cmd("aflc"));
    };
    R2Papi.prototype.analyzeProgram = function (depth) {
        if (depth === undefined) {
            depth = 0;
        }
        switch (depth) {
            case 0:
                this.cmd("aa");
                break;
            case 1:
                this.cmd("aaa");
                break;
            case 2:
                this.cmd("aaaa");
                break;
            case 3:
                this.cmd("aaaaa");
                break;
        }
        return this;
    };
    R2Papi.prototype.enumerateThreads = function () {
        // TODO: use apt/dpt to list threads at iterate over them to get the registers
        var regs0 = this.cmdj("drj");
        var thread0 = {
            context: regs0,
            id: 0,
            state: "waiting",
            selected: true,
        };
        return [thread0];
    };
    R2Papi.prototype.currentThreadId = function () {
        if (+this.cmd("e cfg.debug")) {
            return +this.cmd("dpt.");
        }
        return this.id();
    };
    R2Papi.prototype.setRegisters = function (obj) {
        for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
            var r = _a[_i];
            var v = obj[r];
            this.r2.cmd("dr " + r + "=" + v);
        }
    };
    R2Papi.prototype.hex = function (s) {
        return this.r2.cmd("?v " + s).trim();
    };
    R2Papi.prototype.step = function () {
        this.r2.cmd("ds");
        return this;
    };
    R2Papi.prototype.stepOver = function () {
        this.r2.cmd("dso");
        return this;
    };
    R2Papi.prototype.math = function (expr) {
        return +this.r2.cmd("?v " + expr);
    };
    R2Papi.prototype.stepUntil = function (dst) {
        this.cmd("dsu ".concat(dst));
    };
    R2Papi.prototype.enumerateXrefsTo = function (s) {
        return this.call("axtq " + s).trim().split(/\n/);
    };
    // TODO: rename to searchXrefsTo ?
    R2Papi.prototype.findXrefsTo = function (s, use_esil) {
        if (use_esil) {
            this.call("/r " + s);
        }
        else {
            this.call("/re " + s);
        }
    };
    R2Papi.prototype.analyzeFunctionsFromCalls = function () {
        this.call("aac");
        return this;
    };
    R2Papi.prototype.analyzeFunctionsWithPreludes = function () {
        this.call("aap");
        return this;
    };
    R2Papi.prototype.analyzeObjCReferences = function () {
        this.cmd("aao");
        return this;
    };
    R2Papi.prototype.analyzeImports = function () {
        this.cmd("af @ sym.imp.*");
        return this;
    };
    R2Papi.prototype.searchDisasm = function (s) {
        var res = this.callj("/ad " + s);
        return res;
    };
    R2Papi.prototype.searchString = function (s) {
        var res = this.cmdj("/j " + s);
        return res;
    };
    R2Papi.prototype.searchBytes = function (data) {
        function num2hex(data) {
            return (data & 0xff).toString(16);
        }
        var s = data.map(num2hex).join('');
        var res = this.cmdj("/xj " + s);
        return res;
    };
    R2Papi.prototype.binInfo = function () {
        try {
            return this.cmdj("ij~{bin}");
        }
        catch (e) {
            return {};
        }
    };
    // TODO: take a BinFile as argument instead of number
    R2Papi.prototype.selectBinary = function (id) {
        this.call("ob ".concat(id));
    };
    R2Papi.prototype.openFile = function (name) {
        this.call("o ".concat(name));
    };
    R2Papi.prototype.currentFile = function (name) {
        return this.call('o.').trim();
    };
    R2Papi.prototype.enumeratePlugins = function (type) {
        switch (type) {
            case "bin":
                return this.callj("Lij");
            case "io":
                return this.callj("Loj");
            case "core":
                return this.callj("Lcj");
            case "arch":
                return this.callj("LAj");
            case "anal":
                return this.callj("Laj");
            case "lang":
                return this.callj("Llj");
        }
        return [];
    };
    R2Papi.prototype.enumerateModules = function () {
        return this.callj("dmmj");
    };
    R2Papi.prototype.enumerateFiles = function () {
        return this.callj("oj");
    };
    R2Papi.prototype.enumerateBinaries = function () {
        return this.callj("obj");
    };
    R2Papi.prototype.enumerateMaps = function () {
        return this.callj("omj");
    };
    R2Papi.prototype.enumerateSymbols = function () {
        return this.callj("isj");
    };
    R2Papi.prototype.enumerateExports = function () {
        return this.callj("iEj");
    };
    R2Papi.prototype.enumerateImports = function () {
        return this.callj("iij");
    };
    R2Papi.prototype.enumerateLibraries = function () {
        return this.callj("ilj");
    };
    R2Papi.prototype.enumerateSections = function () {
        return this.callj("iSj");
    };
    R2Papi.prototype.enumerateSegments = function () {
        return this.callj("iSSj");
    };
    R2Papi.prototype.enumerateEntrypoints = function () {
        return this.callj("iej");
    };
    R2Papi.prototype.enumerateRelocations = function () {
        return this.callj("irj");
    };
    R2Papi.prototype.enumerateFunctions = function () {
        return this.cmdj("aflj");
    };
    R2Papi.prototype.enumerateFlags = function () {
        return this.cmdj("fj");
    };
    R2Papi.prototype.skip = function () {
        this.r2.cmd("dss");
    };
    R2Papi.prototype.ptr = function (s) {
        return new NativePointer(s, this);
    };
    R2Papi.prototype.call = function (s) {
        return this.r2.call(s);
    };
    R2Papi.prototype.callj = function (s) {
        return JSON.parse(this.call(s));
    };
    R2Papi.prototype.cmd = function (s) {
        return this.r2.cmd(s);
    };
    R2Papi.prototype.cmdj = function (s) {
        return JSON.parse(this.cmd(s));
    };
    R2Papi.prototype.log = function (s) {
        return this.r2.log(s);
    };
    R2Papi.prototype.clippy = function (msg) {
        this.r2.log(this.r2.cmd("?E " + msg));
    };
    R2Papi.prototype.ascii = function (msg) {
        this.r2.log(this.r2.cmd("?ea " + msg));
    };
    return R2Papi;
}());
G.R2Papi = R2Papi;
var NativePointer = /** @class */ (function () {
    function NativePointer(s, api) {
        if (api === undefined) {
            this.api = G.R;
        }
        else {
            this.api = api;
        }
        // this.api.r2.log("NP " + s);
        this.addr = ("" + s).trim();
    }
    NativePointer.prototype.hexdump = function (length) {
        var len = (length === undefined) ? "" : "" + length;
        return this.api.cmd("x".concat(len, "@").concat(this.addr));
    };
    NativePointer.prototype.functionGraph = function (format) {
        if (format === "dot") {
            return this.api.cmd("agfd@ ".concat(this.addr));
        }
        if (format === "json") {
            return this.api.cmd("agfj@".concat(this.addr));
        }
        if (format === "mermaid") {
            return this.api.cmd("agfm@".concat(this.addr));
        }
        return this.api.cmd("agf@".concat(this.addr));
    };
    NativePointer.prototype.readByteArray = function (len) {
        return JSON.parse(this.api.cmd("p8j ".concat(len, "@").concat(this.addr)));
    };
    NativePointer.prototype.readHexString = function (len) {
        return this.api.cmd("p8 ".concat(len, "@").concat(this.addr)).trim();
    };
    NativePointer.prototype.and = function (a) {
        this.addr = this.api.call("?v ".concat(this.addr, " & ").concat(a)).trim();
        return this;
    };
    NativePointer.prototype.or = function (a) {
        this.addr = this.api.call("?v ".concat(this.addr, " | ").concat(a)).trim();
        return this;
    };
    NativePointer.prototype.add = function (a) {
        this.addr = this.api.call("?v ".concat(this.addr, "+").concat(a)).trim();
        return this;
    };
    NativePointer.prototype.sub = function (a) {
        this.addr = this.api.call("?v ".concat(this.addr, "-").concat(a)).trim();
        return this;
    };
    NativePointer.prototype.writeByteArray = function (data) {
        this.api.cmd("wx " + data.join(""));
        return this;
    };
    NativePointer.prototype.writeAssembly = function (instruction) {
        this.api.cmd("\"wa ".concat(instruction, " @ ").concat(this.addr));
        return this;
    };
    NativePointer.prototype.writeCString = function (s) {
        this.api.call("w " + s);
        return this;
    };
    NativePointer.prototype.isNull = function () {
        return +this.addr === 0;
    };
    NativePointer.prototype.compare = function (a) {
        if (typeof a === "string" || typeof a === "number") {
            a = new NativePointer(a);
        }
        return a.addr === this.addr;
    };
    NativePointer.prototype.pointsToNull = function () {
        return this.readPointer().compare(0);
    };
    NativePointer.prototype.toString = function () {
        return this.addr.trim();
    };
    NativePointer.prototype.writePointer = function (p) {
        var cmd = (+this.api.getConfig("asm.bits") === 64) ? "wv8" : "wv4";
        this.api.cmd("".concat(cmd, " ").concat(p, "@").concat(this));
        // 5.8.2 this.call("wvp " + p.addr);
    };
    NativePointer.prototype.readPointer = function () {
        if (+this.api.getConfig("asm.bits") === 64) {
            return new NativePointer(this.api.call("pv8@" + this.addr));
        }
        else {
            return new NativePointer(this.api.call("pv4@" + this.addr));
        }
    };
    NativePointer.prototype.readU8 = function () {
        return +this.api.cmd("pv1@\"".concat(this.addr));
    };
    NativePointer.prototype.readU16 = function () {
        return +this.api.cmd("pv2@\"".concat(this.addr));
    };
    NativePointer.prototype.readU32 = function () {
        return this.api.cmd("pv4@\"".concat(this.addr));
    };
    NativePointer.prototype.readU64 = function () {
        // XXX: use bignum or 
        return +this.api.cmd("pv8@\"".concat(this.addr));
    };
    NativePointer.prototype.writeInt = function (n) {
        return +this.api.cmd("wv4 ".concat(n, "@").concat(this.addr));
    };
    NativePointer.prototype.writeU8 = function (n) {
        this.api.cmd("wv1 ".concat(n, "@").concat(this.addr));
        return true;
    };
    NativePointer.prototype.writeU16 = function (n) {
        this.api.cmd("wv2 ".concat(n, "@").concat(this.addr));
        return true;
    };
    NativePointer.prototype.writeU32 = function (n) {
        this.api.cmd("wv4 ".concat(n, "@").concat(this.addr));
        return true;
    };
    NativePointer.prototype.writeU64 = function (n) {
        this.api.cmd("wv8 ".concat(n, "@").concat(this.addr));
        return true;
    };
    NativePointer.prototype.readInt = function () {
        return +this.api.cmd("pv4@\"".concat(this.addr));
    };
    NativePointer.prototype.readCString = function () {
        return JSON.parse(this.api.cmd("psj@".concat(this.addr))).string;
    };
    NativePointer.prototype.instruction = function () {
        var op = this.api.cmdj("aoj@".concat(this.addr))[0];
        return op;
    };
    NativePointer.prototype.disassemble = function (length) {
        var len = (length === undefined) ? "" : "" + length;
        return this.api.cmd("pd ".concat(len, "@").concat(this.addr));
    };
    NativePointer.prototype.analyzeFunction = function () {
        this.api.cmd("af@" + this.addr);
        return this;
    };
    NativePointer.prototype.analyzeFunctionRecursively = function () {
        this.api.cmd("afr@" + this.addr);
        return this;
    };
    NativePointer.prototype.name = function () {
        return this.api.cmd("fd " + this.addr).trim();
    };
    NativePointer.prototype.basicBlock = function () {
        var bb = this.api.cmdj("abj@" + this.addr);
        return bb;
    };
    NativePointer.prototype.functionBasicBlocks = function () {
        return this.api.cmdj("afbj@" + this.addr);
    };
    NativePointer.prototype.xrefs = function () {
        return this.api.cmdj("axtj@" + this.addr);
    };
    return NativePointer;
}());
G.NativePointer = NativePointer;
var Base64 = /** @class */ (function () {
    function Base64() {
    }
    Base64.encode = function (x) {
        return (0, G.b64)(x);
    };
    Base64.decode = function (x) {
        return (0, G.b64)(x, true);
    };
    return Base64;
}());
G.Base64 = Base64;
// shell utilities on top of r2pipe
Object.defineProperty(G, "__esModule", { value: true });
G.R2PapiShell = void 0;
var R2PapiShell = /** @class */ (function () {
    function R2PapiShell(papi) {
        this.rp = papi;
    }
    /**
    * Create a new directory in the host system, if the opational recursive argument is set to
    * true it will create all the necessary subdirectories instead of just the specified one.
    */
    R2PapiShell.prototype.mkdir = function (file, recursive) {
        if (recursive === true) {
            this.rp.call("mkdir -p ".concat(file));
        }
        else {
            this.rp.call("mkdir ".concat(file));
        }
        return true;
    };
    /**
    * Deletes a file
    */
    R2PapiShell.prototype.unlink = function (file) {
        this.rp.call("rm ".concat(file));
        return true;
    };
    /**
    * Change current directory
    */
    R2PapiShell.prototype.chdir = function (path) {
        this.rp.call("cd ".concat(path));
        return true;
    };
    R2PapiShell.prototype.ls = function () {
        return this.rp.call("ls -q").trim().split('\n');
    };
    R2PapiShell.prototype.fileExists = function (path) {
        // TODO
        return false;
    };
    /**
    * Opens an URL or application
    * calls `xdg-open` on linux, `start` on windows, `open` on Mac
    */
    R2PapiShell.prototype.open = function (arg) {
        this.rp.call("open ".concat(arg));
    };
    R2PapiShell.prototype.system = function (cmd) {
        this.rp.call("!".concat(cmd));
        return 0;
    };
    R2PapiShell.prototype.run = function (path) {
        this.rp.call("rm ".concat(path));
        return 0;
    };
    R2PapiShell.prototype.mount = function (fstype, path) {
        this.rp.call("m ".concat(fstype, " ").concat(path));
        return true;
    };
    R2PapiShell.prototype.umount = function (path) {
        this.rp.call("m-".concat(path));
    };
    R2PapiShell.prototype.chdir2 = function (path) {
        if (path === undefined) {
            path = "/";
        }
        this.rp.call("mdq ".concat(path));
        return true;
    };
    R2PapiShell.prototype.ls2 = function (path) {
        if (path === undefined) {
            path = "/";
        }
        return this.rp.call("mdq ".concat(path)).trim().split('\n');
    };
    R2PapiShell.prototype.enumerateMountpoints = function () {
        return this.rp.cmdj("mlj");
    };
    R2PapiShell.prototype.isSymlink = function (file) {
        return false;
    };
    R2PapiShell.prototype.isDirectory = function (file) {
        return false;
    };
    return R2PapiShell;
}());
G.R2PapiShell = R2PapiShell;
Object.defineProperty(G, "__esModule", { value: true });
G.EsilParser = G.EsilNode = G.EsilToken = void 0;
// ("this is just a comment"), -- comments are also part of the runtime
/*
=("//", {
    =(obj, {}())
    =([obj, comment], 32)
    if(eq([obj,comment], 32),
        ret()
    )
    ret(obj)
})
*/
class EsilToken {
    constructor(text = "", position = 0) {
        this.label = "";
        this.comment = "";
        this.text = "";
        this.addr = "0"; // for ut64 we use strings for numbers :<
        this.position = 0;
        this.text = text;
        this.position = position;
    }
    toString() {
        return this.text;
    }
}
G.EsilToken = EsilToken;
class EsilNode {
    constructor(token = new EsilToken(), type = "none") {
        this.type = "none";
        this.token = token;
        this.children = [];
    }
    setSides(lhs, rhs) {
        this.lhs = lhs;
        this.rhs = rhs;
    }
    addChildren(ths, fhs) {
        if (ths !== undefined) {
            this.children.push(ths);
        }
        if (fhs !== undefined) {
            this.children.push(fhs);
        }
    }
    toEsil() {
        if (this.lhs !== undefined && this.rhs !== undefined) {
            // XXX handle ?{ }{ }
            let left = this.lhs.toEsil();
            if (left !== "") {
                left += ",";
            }
            let right = this.rhs.toEsil();
            return `${right},${left}${this.token}`;
        }
        return ''; // this.token.text;
    }
    toString() {
        let str = "";
        if (this.token.label !== "") {
            str += this.token.label + ":\n";
        }
        if (this.token.addr !== "0") {
            // str += "//  @ " + this.token.addr + "\n";
        }
        if (this.token.comment !== "") {
            str += "/*" + this.token.comment + "*/\n";
        }
        if (this.token.toString() === "GOTO") {
            if (this.children.length > 0) {
                const children = this.children[0];
                str += "goto label_" + children.token.position + ";\n";
            }
            else {
                // console.log(JSON.stringify(this,null, 2));
                let pos = 0;
                str += `goto label_${pos};\n`;
            }
        }
        if (this.children.length > 0) {
            str += `  (if (${this.rhs})\n`;
            for (let children of this.children) {
                if (children !== null) {
                    const x = children.toString();
                    if (x != "") {
                        str += `  ${x}\n`;
                    }
                }
            }
            str += "  )\n";
        }
        if (this.lhs !== undefined && this.rhs !== undefined) {
            return str + `    ( ${this.lhs} ${this.token} ${this.rhs} )`;
            // return str + `${this.lhs} ${this.token} ${this.rhs}`;
        }
        return str + this.token.toString();
    }
}
G.EsilNode = EsilNode;
class EsilParser {
    constructor(r2) {
        this.cur = 0;
        this.r2 = r2;
        this.cur = 0;
        this.stack = [];
        this.nodes = [];
        this.tokens = [];
        this.root = new EsilNode(new EsilToken("function", 0), "block");
    }
    toJSON() {
        if (this.stack.length > 0) {
            // return JSON.stringify (this.stack, null, 2);
            throw new Error("The ESIL stack is not empty");
        }
        return JSON.stringify(this.root, null, 2);
    }
    toEsil() {
        return this.nodes
            .map((x) => x.toEsil())
            .join(',');
    }
    optimizeFlags(node) {
        if (node.rhs !== undefined) {
            this.optimizeFlags(node.rhs);
        }
        if (node.lhs !== undefined) {
            this.optimizeFlags(node.lhs);
        }
        for (let i = 0; i < node.children.length; i++) {
            this.optimizeFlags(node.children[i]);
        }
        const addr = node.toString();
        if (+addr > 4096) {
            const fname = r2.cmd(`fd.@ ${addr}`).trim().split("\n")[0].trim();
            if (fname != "" && fname.indexOf("+") === -1) {
                node.token.text = fname;
            }
        }
    }
    optimize(options) {
        if (options.indexOf("flag") != -1) {
            this.optimizeFlags(this.root);
        }
    }
    toString() {
        return this.root.children
            .map((x) => x.toString())
            .join(';\n');
    }
    reset() {
        this.nodes = [];
        this.stack = [];
        this.tokens = [];
        this.cur = 0;
        this.root = new EsilNode(new EsilToken("function", 0), "block");
    }
    parseRange(from, to) {
        let pos = from;
        while (pos < this.tokens.length && pos < to) {
            const token = this.peek(pos);
            if (!token) {
                // console.log("BREAK");
                break;
            }
            // console.log(pos, token);
            this.cur = pos;
            this.pushToken(token);
            pos = this.cur;
            pos++;
        }
        // console.log("done");
    }
    parseFunction(addr) {
        var ep = this;
        function parseAmount(n) {
            // console.log("PDQ "+n);
            const lines = r2.cmd("pie " + n + " @e:scr.color=0").trim().split("\n");
            for (const line of lines) {
                if (line.length === 0) {
                    console.log("Empty");
                    continue;
                }
                // console.log("parse", r2.cmd("?v:$$"));
                const kv = line.split(' ');
                if (kv.length > 1) { // line != "") {
                    // console.log("// @ " + kv[0]);
                    //ep.reset ();
                    r2.cmd(`s ${kv[0]}`);
                    ep.parse(kv[1], kv[0]);
                    ep.optimize("flags,labels");
                    //console.log(ep.toString());
                }
            }
            // console.log(ep.toString());
        }
        const oaddr = r2.cmd("?v $$").trim();
        // const func = r2.cmdj("pdrj"); // XXX this command changes the current seek
        if (addr === undefined) {
            addr = oaddr;
        }
        const bbs = r2.cmdj(`afbj@${addr}`); // XXX this command changes the current seek
        for (let bb of bbs) {
            // console.log("bb_" + bb.addr + ":");
            r2.cmd(`s ${bb.addr}`);
            parseAmount(bb.ninstr);
        }
        r2.cmd(`s ${oaddr}`);
    }
    parse(expr, addr) {
        const tokens = expr.trim().split(',').map((x) => x.trim());
        const from = this.tokens.length;
        for (let tok of tokens) {
            const token = new EsilToken(tok, this.tokens.length);
            if (addr !== undefined) {
                token.addr = addr;
            }
            this.tokens.push(token);
        }
        const to = this.tokens.length;
        this.parseRange(from, to);
    }
    peek(a) {
        return this.tokens[a];
    }
    pushToken(tok) {
        if (this.isNumber(tok)) {
            const node = new EsilNode(tok, "number");
            this.stack.push(node);
            this.nodes.push(node);
        }
        else if (this.isInternal(tok)) {
            const node = new EsilNode(tok, "flag");
            this.stack.push(node);
            this.nodes.push(node);
        }
        else if (this.isOperation(tok)) {
            // run the operation login
        }
        else {
            // assume it's a register, so just push the string
            const node = new EsilNode(tok, "register");
            this.stack.push(node);
            this.nodes.push(node);
        }
        // we need a list of register names to do this check properly
        // throw new Error ("Unknown token");
    }
    isNumber(expr) {
        if (expr.toString().startsWith("0")) {
            return true;
        }
        return +expr > 0;
    }
    isInternal(expr) {
        const text = expr.toString();
        return text.startsWith("$") && text.length > 1;
    }
    parseUntil(start) {
        const from = start + 1;
        let pos = from;
        const origStack = [];
        const this_nodes_length = this.nodes.length;
        this.stack.forEach((x) => origStack.push(x));
        while (pos < this.tokens.length) {
            const token = this.peek(pos);
            if (!token) {
                break;
            }
            if (token.toString() === '}') {
                break;
            }
            if (token.toString() === '}{') {
                // return token;
                break;
            }
            // console.log("peek ", this.tokens[pos]);
            pos++;
        }
        this.stack = origStack;
        const to = pos;
        this.parseRange(from, to);
        const same = this.nodes.length == this_nodes_length;
        // console.log("BLOCK ("+ ep.toString());
        if (same) {
            return null;
        }
        return this.nodes[this.nodes.length - 1]; // this.tokens.length - 1];
    }
    getNodeFor(index) {
        const tok = this.peek(index);
        if (tok === undefined) {
            return null;
        }
        for (let node of this.nodes) {
            if (node.token.position === index) {
                return node;
            }
        }
        this.nodes.push(new EsilNode(new EsilToken("label", index), "label"));
        return null;
    }
    findNodeFor(index) {
        for (let node of this.nodes) {
            if (node.token.position === index) {
                return node;
            }
        }
        return null;
    }
    isOperation(expr) {
        switch (expr.toString()) {
            // 1pop1push
            case "[1]":
            case "[2]":
            case "[4]":
            case "[8]":
                if (this.stack.length >= 1) {
                    const i1 = this.stack.pop();
                    // TODO: MemoryReferenceNode(i1));
                    const mn = new EsilNode(i1.token, "operation"); // expr.toString());
                    this.stack.push(i1); // mn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            // 1pop1push
            case "!":
                if (this.stack.length >= 1) {
                    const i0 = new EsilNode(new EsilToken("", expr.position), "none");
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1);
                    this.stack.push(nn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            case "":
            case "}":
            case "}{":
                // no pops or nothing, just does nothing
                return true;
            case "DUP":
                if (true) {
                    if (this.stack.length < 1) {
                        throw new Error("goto cant pop");
                    }
                    const destNode = this.stack.pop();
                    this.stack.push(destNode);
                    this.stack.push(destNode);
                }
                return true;
            case "GOTO":
                // take previous statement which should be const and add a label
                const prev = this.peek(expr.position - 1);
                if (prev !== null) {
                    // TODO: check stack
                    if (this.stack.length < 1) {
                        throw new Error("goto cant pop");
                    }
                    const destNode = this.stack.pop();
                    if (destNode !== null) {
                        const value = 0 | +destNode.toString();
                        if (value > 0) {
                            const destToken = this.peek(value);
                            if (destToken !== undefined) {
                                destToken.label = "label_" + value;
                                destToken.comment = "hehe";
                                const nn = new EsilNode(expr, "goto");
                                const gn = this.getNodeFor(destToken.position);
                                if (gn != null) {
                                    nn.children.push(gn);
                                }
                                this.root.children.push(nn);
                            }
                            else {
                                console.error("Cannot find goto node");
                            }
                        }
                        else {
                            console.error("Cannot find dest node for goto");
                        }
                    }
                }
                return true;
            // controlflow
            case "?{": // ESIL_TOKEN_IF
                if (this.stack.length >= 1) {
                    const i0 = new EsilNode(new EsilToken("if", expr.position), "none");
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1); // left side can be ignored for now.. but we can express this somehow
                    let trueBlock = this.parseUntil(expr.position);
                    let falseBlock = null;
                    // nn.addChildren(trueBlock, falseBlock);
                    if (trueBlock !== null) {
                        nn.children.push(trueBlock);
                        this.nodes.push(trueBlock);
                        falseBlock = this.parseUntil(trueBlock.token.position + 1);
                        if (falseBlock !== null) {
                            nn.children.push(falseBlock);
                            this.nodes.push(falseBlock);
                        }
                    }
                    // console.log("true", trueBlock);
                    // console.log("false", falseBlock);
                    // this.stack.push(nn);
                    this.nodes.push(nn);
                    this.root.children.push(nn);
                    if (falseBlock !== null) {
                        this.cur = falseBlock.token.position;
                    }
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            case "-":
                if (this.stack.length >= 2) {
                    const i0 = this.stack.pop();
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1);
                    if (this.stack.length === 0) {
                        //	this.root.children.push(nn);
                    }
                    this.stack.push(nn);
                    this.nodes.push(nn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            // 2pop1push
            case "<":
            case ">":
            case "^":
            case "&":
            case "|":
            case "+":
            case "*":
            case "/":
            case ">>=":
            case "<<=":
            case ">>>=":
            case "<<<=":
            case ">>>>=":
            case "<<<<=":
                if (this.stack.length >= 2) {
                    const i0 = this.stack.pop();
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1);
                    if (this.stack.length === 0) {
                        //	this.root.children.push(nn);
                    }
                    this.stack.push(nn);
                    this.nodes.push(nn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            // 2pop0push
            case "=":
            case ":=":
            case "-=":
            case "+=":
            case "==":
            case "=[1]":
            case "=[2]":
            case "=[4]":
            case "=[8]":
                if (this.stack.length >= 2) {
                    const i0 = this.stack.pop();
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1);
                    if (this.stack.length === 0) {
                        this.root.children.push(nn);
                    }
                    this.nodes.push(nn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
        }
        return false;
    }
}
G.EsilParser = EsilParser;
